title: 程序调试总结
date: 2015-11-27 21:22:57
tags: [debug, gdb]

---

回顾大学四年，从hello world到现在的互联网应用程序，一气呵成写完代码不需要debug直接就能使用的程序真的寥寥无几，从大学到现在刚毕业参加工作这么长的时间，一些调试的经验零零碎碎存在我的笔记本里面，现在在这里总结一下。

## 错误类型
  既然是要除错，那么会遇到哪几种错误就是要解决的第一个问题。
  我认为遇到的错误无非就是以下三种：
- [x] 功能定义错误
- [x] 设计规划错误
- [x] 代码编写错误

### 功能定义错误
  如果程序的功能被错误地定义了，那么它就肯定不能完成预定的工作。所以，在开始程序设计之前，必须确认自己知道并理解这个程序究竟是用来干什么的。

### 设计规划错误
  无论程序规模的大小，在创建它们之前都需要设计规划。如何构造程序，需要什么样的数据结构，又应该如何在程序中使用，这些如果设计错误的话，这样增加很多以后改写代码的时间。

### 代码编写错误
  比如写代码的时候这里少了个分号，那里有多了个括号。在程序中遇到错误时，要重新阅读源代码。
  
  需要调试的错误多是代码编写错误。
  
## 程序调试的5个阶段

 - [x] 测试：找出程序中存在的缺陷或错误
 - [x] 固化：让程序的错误可重现
 - [x] 定位：确定相关的代码行 
 - [x] 纠正：修改代码纠正错误
 - [x] 验证：确定修改解决了问题

 主要就是定位错误。
 
## 调试程序的3个方法
1，试错法：这种方法多用于调用中间件的接口，比如rabbitmq的接口。由于传入的参数不符合接口的定义导致错误或者直接就是调错了接口。这种就需要借助google查资料，然后更换接口，再次编译运行看是否出错。

2，取样法：在程序中加入一些语句来获得更多关于程序内部运行情况的信息，简单的说就是printf来简单粗暴地调试，打印出变量在程序运行的不同阶段的值（gdb的watch也有这个功能)，或者就是在printf的位置打上日志，通过查看日志来获取变量的值。这种方法多用于程序能跑通，但是功能定义错误，并没有实现要求的功能。

3，受控执行法：就是通过控制程序的执行与停止来调试，就是使用断点中止程序的运行，然后打上补丁之后继续执行然后查看结果。因为我用C++，所以这里我使用gdb来打断点。这种方法多用于程序core dump，因为只要程序不出错误，那么程序就会停在断点处，如果程序出错那么抛出错误，通过不停越过断点可以快速定位代码崩溃的位置，然后再使用取样法监控变量的值来定位错误的原因。而当程序能跑通的时候，出现功能定义错误，那么就必须监控变量的值的变化（看日志），才能定位错误。

  三种方法其实都是一种思想：让程序执行到某一步，并把这一步的某个变量值打印出来看看。当能够随时控制程序的运行和停止的，就是受控执行法（比如gdb或者IDE的打断点），当不能控制程序中间停止的就是取样法（就是把本来想要打断点的位置换成printf函数，可以printf出一行加号或者一行等于号或者一行1，反正就是一个标记，就是在输出的终端上看到程序执行到了什么位置上了。）。

## 程序的三种错误

### 编译期错误
  这就属于错误类型当中的"代码编写错误”类型。静态语言能够利用编译器来找到语法错误。一般来说使用g++的错误日志就能定位到错误所在
  
### 运行期错误
  常见的有segementation fault和core dump。这种错误就是编译没有问题，然后运行的时候会抛出错误。
  如果一个程序在运行的时候输出是segementation fault的话，这就是段错误，说明操作系统向程序发送了一个信号，告诉程序操作系统检测到了非法的内存访问，为防止内存空间被破坏，操作系统提前终止了该程序的运行。segementation fault也是core dump的一种,不过这种我遇到的比较多。
  而core dump也是操作系统向程序发送的信号，它产生的原因有但不限于以下几种：
  1，多线程程序使用了线程不安全的函数
  2，多线程读写的变量数据未加锁保护
  3，野指针
  
  以上三种仅仅是我遇到过的core dump。
  coredump会使得程序停止服务一段时间，但是coredump文件会保留当前进程的第一手现场资料，这些信息包含了程序运行时的内存，寄存器状态，堆栈指针，内存管理信息还有各种函数调用堆栈信息等，以便后续调试。
  当出现segement fault的时候，首先我想到的就是使用gdb来调试，因为正常运行一定会抛出错误，所以用受控执行，比如一个test.cpp:
  
```
#include <iostream>

using namespace std;

void test(int* array) {
  for (int i= 0; i<20; ++i) {
    cout << array[i] << endl;
    array[i] = 100;
  }
}

void func() {
  int array[5] = {0, 1, 2, 3, 4}; 
  test(array);
}

int main(int argc, char** argv) {
  func();
  return 0;
}

```
为了使用gdb，编译要加上-g参数
```
g++ -g -o test test.cpp 
```
执行./test，抛出segemetation fault错误
```
[xiongjun@ubuntu ~]% ./test 
0
1
2
3
4
32766
0
0
22487552
32766
4196580
0
22487784
32766
0
1
0
0
1735843525
32591
[1]    9291 segmentation fault (core dumped)  ./test
```
按照前面说的程序调试的的思想，使用gdb来打断点
```
gdb test
```
然后在三个函数执行之前分别打上断点
```
(gdb) b main
Breakpoint 1 at 0x4008df: file test.cpp, line 18.
(gdb) b func
Breakpoint 2 at 0x40089f: file test.cpp, line 13.
(gdb) b test
Breakpoint 3 at 0x400839: file test.cpp, line 6.
```
使用`run`来在gdb当中运行程序,程序如果不出错的话将停在断点处,
使用`continue`越过这个断点继续执行。
越过test这个断点的时候抛出错误，并且test之后没有断点，就是程序的结尾了
```
Program received signal SIGSEGV, Segmentation fault.
0x0000006400000064 in ?? ()
```
就说明程序崩溃的位置在于test这个函数从开始到结束的位置之间，现在已经把崩溃的代码定位到一个很小的范围，这个时候就要查看变量的值来获取更多信息。gdb的watch有这个功能
```
(gdb) watch i                                                           Hardware watchpoint 7: i                                                 
(gdb) watch array[i]                                                                                                
Hardware watchpoint 8: array[i]  
```
使用`continue`继续运行,当watch监控的变量有变化的时候将打印出Old value和New value
```
(gdb) c
Continuing.
Hardware watchpoint 7: i

Old value = 1
New value = 2
Hardware watchpoint 8: array[i]

Old value = 100
New value = 2
```

或者直接使用gdb的print功能，就能打印出断点出的变量的值,不过watch更好，能自动监控
```
(gdb) print i
$3 = 1
(gdb) print array[i]
$4 = 1
(gdb) 
```
这里虽然是一个很简单的数组越界错误，但是用到的调试方法可以原封不动地用在大程序的调试上。

### 运行结果不符合

功能定义错误，设计规划错误，代码编写错误都会导致运行结果不符合的情况产生。这个时候我一般用的是取样法，因为程序能正确结束，并把每一步的结果dump下来看一下是否正确，如果出现不正确的结果，就能确定代码错误出现在那一行。
为此，如果用C++设计一个资源管理的class的时候，特别需要一个dump函数。比如在我的数据库连接池DBPool当中，我使用RAII的方法来设计我的MysqlObj。其中就有Dump函数：
```
void MysqlObj::Dump() const { 
  printf("\n=====MysqlObj Dump START ========== \n");
  printf("pMysql_=%p ", pMysql_);
  printf("strHost_=%s ", strHost_.c_str());
  printf("strUser_=%s ", strUser_.c_str());
  printf("strPassword_=%s ", strPassword_.c_str());
  printf("strDBname_=%s ", strDBname_.c_str());
  printf("iPort_=%d ", iPort_);
  printf("strErrorMessage_=%s ", strErrorMessage_.c_str());
  printf("iAffectedRows_=%d ", iAffectedRows_);
  printf("iInsertId_=%d ", iInsertId_);
  printf("\n===MysqlObj DUMP END ============\n");
}
```
调试这种错误的思想就是监控变量的值。反映到printf的简单粗暴的调试方法就是使用dump，而反映到gdb上来说就是watch这个功能。

## 尾声

程序出了bug，一般认为bug之间的影响是独立的（如果有两个bug相互影响，将其中一个bug改正忽略了另外一个bug导致程序崩溃，而两个bug同时存在程序反而不会崩溃，那这种bug就很难调试了），那么就从函数的起始函数开始，每个函数的入口处都打上断点或者printf。监控程序执行到哪一个函数崩溃了，就是这个函数的问题。然后将函数执行的前后的相关变量值dump出来看一下，看看函数到底错在哪里。当然这是软件的debug版本的使用方法，而release版本的话，不可能有那么多的printf打印出来，这个时候要使用C++的技巧：
利用C++的预处理器有选择地包括取样代码：如果定义了DEBUG宏，那么就执行代码
```
#ifdef DEBUG
printf("===============\n");
//如果觉得printf会在终端上打印出太多的信息，不好查看，可以使用日志库来打日志
LOG(INFO) << "===============\n";
#endif
```
DEBUG宏不需要在程序当中指定，只需要在g++编译的时候指定-DDEBUG，就定义了DEBUG宏。
在我打日志的时候，有几个编译器的内置宏很有用
由于是编译器内置的，所以能直接使用

| 编译器内置宏        | 含义   |
| --------            | -----:  |
| \__FILE\__        | 代表当前文件名的字符串 | 
| \__LINE\__        |   代表当前行号  | 
| \__DATE\__        |   mmm dd yyyy格式的字符串，代表当前日期    | 
| \__TIME\__        |   mmm dd yyyy格式的字符串，代表当前时间    | 

就像我的`debug.h`头文件当中使用了：
```
#define BUG_FILE() \
{ \
    std::cerr << " FILE(" << __FILE__ << "), LINE(" << __LINE__ << ")" << std::endl; \
}
```
在每次需要printf的地方，我直接使用`BUG_FILE()`来代替，将打印出文件名和行号。



如果不使用printf，想使用gdb的话，由于编译时候使用`g++ -g`会在最终生成的可执行文件当中加入大量的调试信息，那么调试完成之后，需要使用
```
strip <file>
```
来删除掉可执行文件当中多余的调试信息，避免影响发布。
