title: 使用boost::property_tree解析xml与json (二):parse_xml设计
date: 2015-12-13 01:02:07
categories: property_tree
tags: [boost, property_tree, xml]
---

> 请注意，这段代码只能运行在`boost`的版本比较高的情况下。我的`ubuntu 14.04LTS`的`boost`版本是`1.54`，所以能编译通过，但是今天我在我的`centos 6.5`上编译通不过，因为我的`centos 6.5`的`boost`版本是`1.41`。我在`centos 6.5`下是用`yum`安装`boost`的命令是
```
yum -y groupinstall "Development Tools"
yum -y install boost-*
```
然而这个`yum -y install boost-*`在我的`zsh`环境下执行不了，我只好切换到`bash`执行。`boost`安装路劲是`/usr/include/boost`，然后有一个专门的`version.hpp`是显示`boost`版本的，这个时候我查看到我用`yum`安装的`boost`是`1.41`版本。随后我重新下载了`boost`的源代码，使用`b2`安装了最新版。不得不说`centos`的软件更新速度真是慢。同样是安装，我的`Ubuntu 14.04LTS`用的是
```
sudo apt-get install libboost-all-dev
```
安装的`boost`就是`1.54`版本。

=========================== 2015年12月13日 ========================================

## class的设计

这个`ParseXmlObj`的设计当然和前面一样都是遵守RAII的法则。这个构造函数的设计很简单，就是通过传入`xml`文件的路径从而得到`ParseXmlObj`的对象的。默认路径是`../config/messageQueue.xml`。

使用方法很简单：
```
ParseXmlObj myXml("../config/testXml.xml");
```
这样就根据`../config/testXml.xml`构造了`ParseXmlObj`对象。


### 有关智能指针的初始化：

需要提到的一点是有关智能指针作为类的成员的时候，类初始化必须把智能指针放在初始化列表：
是这样的，由于解析`xml`必须用到`ptree`类型的对象，所以我把它封装在了`ParseXmlObj`的成员当中，但是由于我并不知道`ptree`初始化需要什么样的参数，换句话来说，就是如果`ParseXmlObj`的成员是`ptree`类型的对象，那么构造函数初始化的时候就会失败，为了避免这种情况，我使用指针来充当成员而不是使用`ptree`的对象。
对于指针的使用，我早就条件反射式的用`shared_ptr`，可以说我已经不用普通指针很多年了:）
那么在构造函数当中就需要解决`shared_ptr`成员的初始化。
> `shared_ptr`的初始化必须使用初始化列表

正确的形式是这样的：
```
ParseXmlObj::ParseXmlObj() 
    : pt_(new ptree) {
    configPath_ = "../config/messageQueue.xml";
    //pt_ = new ptree;
    boost::property_tree::read_xml(configPath_, *pt_);
}
```

如果写成这种形式将编译通不过：
```
ParseXmlObj::ParseXmlObj() {
    configPath_ = "../config/messageQueue.xml";
    pt_ = new ptree;
    //或者这种形式编译也通不过:  
    //pt_(new ptree);
    boost::property_tree::read_xml(configPath_, *pt_);
}
```

### 有关std::move
`std::move`是用来减少不必要的拷贝和销毁的。有关`std::move`和`RVO（Return value optimization）`也就是编译器做的返回对象的优化，可以参看这篇英文文章[RVO V.S. std::move](https://www.ibm.com/developerworks/community/blogs/5894415f-be62-4bc0-81c5-3956e82276f3/entry/RVO_V_S_std_move?lang=en)，写的很好，我想有空的话我来做个翻译。

## 想法

解析`xml`我觉得有以下几种情况：
### 直接获取`xml`的标签的值，
```
<root>
   <child>
    <a>“1”</a>
    <b>2</b>
  </child>
 </root>
```
比如说我想要直接获取`<a>`标签的值，这种情况是我已经知道了标签的名字和路径。
这个时候我提供了一个接口：
```
string GetChildData(const string& path);
```
用于处理已经知道标签的路径，想要得到标签里面的值的情况。

### 获取所有子标签

我不知道这个标签下有多少个子标签，但是我知道这些子标签的格式都是最简单的`<key>value</key>`型:
就是说这些子标签不会有它们自己的子标签，而且也没有`attribute`, 而且这些子标签的标签名不会有重复。

比如这个`xml`当中的`child`标签：
```
<root>
   <child>
    <a>“1”</a>
    <b>2</b>
  </child>
 </root>
```
对于这种情况，我提供了接口：
```
map<string, string> GetChildDataMap(const string& path);
```
`map`的`first`就是标签名，`second`就是标签值。
由于子标签的标签名不会有重复，所以可以保证数据的完整性。

### 获取所有孙标签

我不知道这个标签下有多少个子标签，也不知道有多少个孙标签，但是我知道这些子标签的格式，以及孙标签的格式。

子标签的格式就是没有`attribute`的`<key>value</key>`型，孙标签也是。

比如这里的`root`标签：

```
<root>
  <child>
    <a>"1"</a>
    <b>2</b>
  </child>
  <newchild>
    <a>"3"</a>
    <b>"4"</b>
  </newchild>
</root> 
```
我认为用的最多的场景就是这样的：每个子标签格式相同（值的是孙标签不多也不少，而且孙标签的名字都相同），每个子标签代表这初始化一个资源所需的参数（就想我的[server_connection_pool.cpp](https://github.com/adairjun/SocketPool/blob/master/util/server_connection_pool.cpp)一样)，用这个接口可以快速初始化所有资源。这也是我想写`parse_xml.cpp`代码的原因所在。

当然不符合“每个子标签格式相同”的这个场景也没问题，因为这里用的是`map`，对于`key`没有任何要求。

```
vector<map<string, string> > GetChildDataArray(const string& path);
```
仔细看这个接口，由于孙标签是`map`，所以一个子标签下的孙标签的标签名不能相同。由于子标签是`vector`，就是说子标签的标签名不会存储在`vector<map<string, string> >`当中，所以子标签的标签名随便写。

其实刚开始我是没有设计这个接口的，但是因为`parse_json.cpp`当中有获取数组的接口，所以我在`xml`的解析当中也就顺带实现了这么一个接口。


### 得到一个标签的`attribute`
已经知道标签的路径，和`attribute`的名字，就能获取`attribute`的值。
比如
```
<errors>
  <error id="DB_ERROR_EXECUTE" value="1" prompt="操作数据库失败" msg="操作数据库失败" test="ttttt"/>
  <error id="DB_ERROR_COMMAND" value="2" prompt="创建数据库操作指令失败" msg="创建数据库操作指令失败"/>
</errors>
```
这种情况，根据路径`errors.error`能获取到两个标签，那么我的这个接口就只能返回第一个标签指定的`attribute`。这个接口只能处理一个路径下只有一个标签的情况。

```
string GetAttr(string path, const string& attr);
```

### 得到一组`attribute`
如果要获得`errors`这个父标签下的所有子标签的指定的`attribute`，就可以使用这个接口：
```
vector<string> GetAttrArray(string path, const string& attr);
```
比如这样使用
```
 GetAttrArray("errors", "id");
```
获取`errors`标签下所有子标签的`id`这个`attribute`。

### 根据已经知道的`attribute`去查找未知的`attribute`
我认为更多的关于`attribute`的使用是用这个接口
```
string GetAttrByAttr(string path, const string& know_attr, const string& know_value, const string& attr);
```
比如已知了`id`，要想拿到`value`。很多情况下在自己的代码当中要用到错误码的时候，都是用`string`类型的，这个时候，就要用到这个接口，根据`id`来找到错误码的对应的值。

比如:
```
GetAttr("errors", "id", "DB_ERROR_EXECUTE", "value");
```
就是在`errors`标签下遍历，找到`id`等于`DB_ERROR_EXECUTE`这个标签，并取出这个标签当中`value`这个`attribute`的值。
根据这个接口就能够建立起来`attribute`到`attribute`的映射关系。


## 插入数据的操作
我觉得`xml`和`json`多用于配置文件，绝大多数情况下都是程序读取配置文件，而不是程序写入配置文件，写配置文件只要人为写入就可以了，而且配置文件都是具有重复性，只要复制下来改一改就好了。

但是我在这里还是实现了几个写配置文件的接口。

### 加入一个`<key>value</key>`标签

最简单的形式，自己构建一个路径，把路径和值传给接口：

```
void PutChildData(const string& key, const string& value);
```
比如：
```
PutChildData("testput.a.b.c", "1");
```
就能够产生这种`xml`:
```
<testput>
  <a>
    <b>
      <c>"1"</c>
    </b>
  </a>
</testput>
```
`testput`这个标签并不需要已经存在，同理`a`，`b`，`c`也是。

### 插入一个父标签

由于使用了`map`所以插入的数据的标签不一样。
```
void PutChildDataMap(const string& key, const map<string, string>& key_value_map);
```
比如说我要插入一个`<newchild>`的父标签在这个`xml`当中：
```
<root>
<child>
<a></a>
<b></b>
</child>
</root>
```

那就应该这样用：
```
myMap.insert(make_pair("a", "1"));
myMap.insert(make_pair("b", "2"));
PutChildData("root.newchild", myMap);
```

得到结果是：
```

<root>
<child>
<a></a>
<b></b>
</child>
<newchild>
<a>"1"</a>
<b>"2"</b>
</newchild>
</root> 
```

### 插入一个数组

这个只要重复调用上面的“插入一系列数据”的接口就可以了。

### 插入一个新的`attribute`

```
void PutAttr(string path, const string& attribute, const string& attrvalue);
```

这个接口对应的是
```
string GetAttr(string path, const string& attr);
```
同样的，调用`PutAttr`接口的路径下也只能找到唯一的一个标签，否则只会对第一个标签做操作。
使用方法：
```
PutAttr("errors.error", "id", "DB_ERROR_EXECUTE");
```
得到结果
```
<errors>
   <error id="DB_ERROR_EXECUTE"/>
</errors>
```

至于在一组标签中都插入`attribute`的接口我觉得这个实现实在是没有必要，因为如果设计出来必然是这样的形式:

```
void PutAttrArray(string path, const string& attr, const string& attrvalue);
```
这样操作的结果就是在一组标签下都加入相同的`attribute`，关键还是`attribute`的值都一模一样，那这种操作根本没有意义，因为每一个标签都有相同的`attribute`的值，毫无区分性可言。

### 创建一个新行，并插入一组`attribute`，
如果对单一的标签插入一组`attribute`的话，可以反复调用上面的接口`PutAttr`，但是这里为了加入一行新行，我特意写了这个接口
```
void AddLineByAttr(string path, const map<string, string>& key_value_map);
```

使用方法：
```
myMap.insert("id", "ttt");
myMap.insert("value", "000");
myMap.insert("prompt", "ppp");
myMap.insert("msg", "mmm");
AddLineByAttribute("errors.error", myMap);
```
得到结果：
```
<errors>
  <error id="ttt" value="000" prompt="ppp" msg="mmm"/>
</errors>
```

### 保存结果

在对`xml`进行写入之后，不要忘记调用接口
```
void SaveConfig();
```
来保存结果。
因为之前的写入都是写入到`ptree`这个数据结构当中的，使用这个接口将`ptree`的数据同步到`xml`文件。

## 我的测试详情请访问[test_xml.cpp](https://github.com/adairjun/MQPool/blob/master/gtest/test_xml.cpp)

## 最后贴上完整的源代码：

## `parse_xml.h`

```
#ifndef MQPOOL_INCLUDE_PARSE_XML_H_
#define MQPOOL_INCLUDE_PARSE_XML_H_

/* 以前一直都是把解析xml文件的代码放在池的构造函数当中,这里把它独立出来
 *  使用boost的xml解析库,也推荐使用rapidxml,而且boost的xml解析库用的就是rapidxml
 */

#include <string>
#include <vector> 
#include <map>
#include <boost/shared_ptr.hpp>
#include <boost/property_tree/ptree.hpp>

using std::string;
using std::vector;
using std::map;
using std::make_pair;
using boost::property_tree::ptree;

typedef boost::shared_ptr<boost::property_tree::ptree> ptreePtr;

class ParseXmlObj {
 public:
  explicit ParseXmlObj();
  explicit ParseXmlObj(string configPath);
  virtual ~ParseXmlObj();
  ParseXmlObj(const ParseXmlObj&) = delete;
  ParseXmlObj& operator=(const ParseXmlObj&) = delete;
  void Dump() const;

  string GetConfigPath() const;

  ptreePtr GetPtree() const;

  /*
   * GetChildData("root.child.a") will get <a> 
   * <root>
   *   <child>
   *     <a></a>
   *     <b></b>
   *   </child>
   * </root>
   */
  string GetChildData(const string& path);

  /*
   * GetChildData("root.child") will get <a> and <b>
   * <root>
   *   <child>
   *     <a></a>
   *     <b></b>
   *   </child>
   * </root>
   */
  map<string, string> GetChildDataMap(const string& path);

  /*
   * 请注意这里和parse_json当中的GetChildData的区别，严格的来说xml并没有数组的概念
   * 这里只是为了方便拿数据所以实现了这个接口
   * GetChildData("root") will get <a> and <b>
   * <root>
   *   <child>
   *     <a></a>
   *     <b></b>
   *   </child>
   *   <child>
   *     <a></a>
   *     <b></b>
   *   </child>
   * </root>
   */
  vector<map<string, string> > GetChildDataArray(const string& path);

  /*
   * get attribute by path
   * GetAttr("errors.error", "id") get the first attribute
   *  <errors>
   *  <error id="DB_ERROR_EXECUTE" value="1" prompt="操作数据库失败" msg="操作数据库失败" test="ttttt"/>
   *  <error id="DB_ERROR_COMMAND" value="2" prompt="创建数据库操作指令失败" msg="创建数据库操作指令失败"/>
   *  </errors>
   * the result is "1"
   */
  string GetAttr(string path, const string& attr);

  /*
   * get attribute by path
   * GetAttrArray("errors", "id") get the first attribute
   *  <errors>
   *  <error id="DB_ERROR_EXECUTE" value="1" prompt="操作数据库失败" msg="操作数据库失败" test="ttttt"/>
   *  <error id="DB_ERROR_COMMAND" value="2" prompt="创建数据库操作指令失败" msg="创建数据库操作指令失败"/>
   *  </errors>
   * the result is a vector
   */
  vector<string> GetAttrArray(string path, const string& attr);

  /*
   * get attribute by path and attribute
   * GetAttr("errors", "id", "DB_ERROR_EXECUTE", "value") get the "value" attribute where "id" is "DB_ERROR_EXECUTE"
   * 注意这个接口的path传的是errors 而不是errors.error
   *  <errors>
   *  <error id="DB_ERROR_EXECUTE" value="1" prompt="操作数据库失败" msg="操作数据库失败" test="ttttt"/>
   *  <error id="DB_ERROR_COMMAND" value="2" prompt="创建数据库操作指令失败" msg="创建数据库操作指令失败"/>
   *  </errors>
   * result is "1"
   */
  string GetAttrByAttr(string path, const string& know_attr, const string& know_value, const string& attr);

  //===========================================================
  /*
   * PutChildData("testput", "testput") will add "testput" in
   * <root>
   *   <child>
   *     <a></a>
   *     <b></b>
   *   </child>
   * </root>
   * new:
   * <root>
   *   <child>
   *     <a></a>
   *     <b></b>
   *   </child>
   * </root>
   * <testput>"testput"</testput>
   */
  void PutChildData(const string& key, const string& value);

  /*
   * myMap.insert(make_pair("a", "1"))  myMap.insert(make_pair("b", "2"))
   * PutChildData("root.newchild", myMap) will add "newchild" in
   * <root>
   *   <child>
   *     <a></a>
   *     <b></b>
   *   </child>
   * </root>
   * new:
   * <root>
   *   <child>
   *     <a></a>
   *     <b></b>
   *   </child>
   *   <newchild>
   *     <a></a>
   *     <b></b>
   *   </newchild>
   * </root> 
   */
  void PutChildDataMap(const string& key, const map<string, string>& key_value_map);

  /*
   * 上面说过了xml并没有数组的概念,所以这里没有 PutChildDataArray()函数
   */

  /*
   * PutAttr("errors.error", "id", "DB_ERROR_EXECUTE") 
   * <error id="DB_ERROR_EXECUTE"/>
   */
  void PutAttr(string path, const string& attribute, const string& attrvalue);

  /*
   * 这个通过attribute找到对应的标签，再在标签中加入一个attribute的功能很难实现,所以这个函数就没有实现 PutAttrByAttr()
   * 而且我觉得要用到这个功能会比较少
   */
   
  /*
   *
   * add a new line in xml 
   * myMap.insert("id", "ttt");
   * myMap.insert("value", "000");
   * myMap.insert("prompt", "ppp");
   * myMap.insert("msg", "mmm");
   * AddLineByAttribute("errors.error", myMap);
   *  <errors>
   *  <error id="DB_ERROR_EXECUTE" value="1" prompt="操作数据库失败" msg="操作数据库失败" />
   *  <error id="DB_ERROR_COMMAND" value="2" prompt="创建数据库操作指令失败" msg="创建数据库操作指令失败"/>
   *  </errors>
   * new:
   *  <errors>
   *  <error id="DB_ERROR_EXECUTE" value="1" prompt="操作数据库失败" msg="操作数据库失败" />
   *  <error id="DB_ERROR_COMMAND" value="2" prompt="创建数据库操作指令失败" msg="创建数据库操作指令失败"/>
   *  <error id="ttt" value="000" prompt="ppp" msg="mmm"/>
   *  </errors>
   */
  void AddLineByAttr(string path, const map<string, string>& key_value_map);

  /*
   * save config
   */
  void SaveConfig();

 private:
  string configPath_; 
  //这里不用ptree对象而用指针的意义在于如果使用ptree对象的话，构造的时候就必须完全构造这个对象
  ptreePtr pt_;
  //ptree* pt_;
};

typedef boost::shared_ptr<ParseXmlObj> ParseXmlObjPtr;
#endif /* MQPOOL_INCLUDE_PARSE_XML_H */
```






## `parse_xml.cpp`

```
#include "MQPool/parse_xml.h"
#include <boost/property_tree/xml_parser.hpp>


ParseXmlObj::ParseXmlObj() 
    : pt_(new ptree) {
    configPath_ = "../config/messageQueue.xml";
    //pt_ = new ptree;
    boost::property_tree::read_xml(configPath_, *pt_);
}

ParseXmlObj::ParseXmlObj(string configPath)
    : configPath_(configPath), pt_(new ptree) {
    //pt_ = new ptree;
	boost::property_tree::read_xml(configPath_, *pt_);
}

ParseXmlObj::~ParseXmlObj() {
  //delete pt_;
}

void ParseXmlObj::Dump() const {
  printf("\n=====ParseXmlObj Dump START ========== \n");
  printf("configPath__=%s ", configPath_.c_str());
  //printf("pt_=%p ", pt_);
  printf("\n===ParseXMlObj DUMP END ============\n");
}

string ParseXmlObj::GetConfigPath() const {
	return configPath_;
}

ptreePtr ParseXmlObj::GetPtree() const {
	return pt_;
}

string ParseXmlObj::GetChildData(const string& path) {
  return pt_->get<string>(path);
}

map<string, string> ParseXmlObj::GetChildDataMap(const string& path) {
  map<string, string> key_value_map;
 
  auto child = pt_->get_child(path);
  for (auto pos = child.begin(); pos!= child.end(); ++pos) {
    key_value_map.insert(make_pair(pos->first, pos->second.data()));
  }
  return std::move(key_value_map);
}

vector<map<string, string> > ParseXmlObj::GetChildDataArray(const string& path) {
  vector<map<string, string> > result_array;
  map<string, string> key_value_map;
 
  auto child = pt_->get_child(path);
  for (auto pos = child.begin(); pos!= child.end(); ++pos) {
    auto nextchild = pos->second.get_child("");
    for (auto nextpos = nextchild.begin(); nextpos!= nextchild.end(); ++nextpos) {
      key_value_map.insert(make_pair(nextpos->first, nextpos->second.data()));
    }
    result_array.push_back(key_value_map);
    key_value_map.clear();
  }
  return std::move(result_array);
}

string ParseXmlObj::GetAttr(string path, const string& attr) {
  if(pt_ == NULL || attr == "")
    return "";
  if(path != ""){
    path += "."; //add the domain descriptor
  }
  path += "<xmlattr>.";
  path += attr;
  return pt_->get<string>(path, "");
}

vector<string> ParseXmlObj::GetAttrArray(string path, const string& attr) {
  vector<string> result;
  if (pt_ != NULL && attr != "") {
    auto child = pt_->get_child(path);
    for (auto pos = child.begin(); pos!= child.end(); ++pos) {
      auto nextchild = pos->second.get_child("");
      for (auto nextpos = nextchild.begin(); nextpos!= nextchild.end(); ++nextpos) {
        result.push_back(nextpos->second.get<string>(attr));
      }
    }
  }
  return std::move(result);
}

string ParseXmlObj::GetAttrByAttr(string path, const string& know_attr, const string& know_value, const string& attr) {
  string result = "";
  auto child = pt_->get_child(path);
  for (auto pos = child.begin(); pos!= child.end(); ++pos) {
    auto nextchild = pos->second.get_child("");
    for (auto nextpos = nextchild.begin(); nextpos!= nextchild.end(); ++nextpos) {
      if (nextpos->second.get<string>(know_attr) == know_value) {
        result = nextpos->second.get<string>(attr); 
        break;
      }
    }
  }
  return result;
}


void ParseXmlObj::PutChildData(const string& key, const string& value) {
  if(pt_ != NULL) {
    pt_->put(key, value);
  }
}

void ParseXmlObj::PutChildDataMap(const string& key, const map<string, string>& key_value_map) {
  if(pt_ != NULL) {
    ptree child;
    for (auto myPair : key_value_map) {
      child.put(myPair.first, myPair.second);
    }
    pt_->add_child(key, child);
  }
}

void ParseXmlObj::PutAttr(string path, const string& attribute, const string& attrvalue) {
  if (pt_ != NULL) {
	if(path != "") {
	  path += "."; //add the domain descriptor
	}
	path += "<xmlattr>.";
	path += attribute;
	pt_->put<string>(path, attrvalue);
  }
}

void ParseXmlObj::AddLineByAttr(string path, const map<string, string>& key_value_map) {
  if (pt_ != NULL) {
    ptree temp;
    for (auto myPair : key_value_map) {
      temp.put<string>("<xmlattr>." + myPair.first, myPair.second.data());  
    } 
    pt_->add_child(path, temp);
  }
}

void ParseXmlObj::SaveConfig() {
  if(pt_ != NULL) {
    boost::property_tree::write_xml(configPath_, *pt_);
  }
}

```



