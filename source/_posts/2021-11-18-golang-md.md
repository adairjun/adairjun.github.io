---
title: golang.md
date: 2021-11-18 09:31:13
Tags:
---

## 了解该语言的基本数据类型，基本语法和主要语言构造；主要数学运算符和print函数的使用，达到能够写课后习题水平；

print函数: 

```go
import ("fmt")

fmt.Printf("%d", 1)
```

基本语法：

变量使用var
```go
var i int = 5 // int
i := 5 // 自动类型推导
var j string = "this is string" // string
j := "this is string" // 自动类型推导

// 数组前面必须加类型
var k = [...]int{1,2,3,4,5} // array
k := [...]int{1,2,3,4,5} // 自动类型推导

// go 语言数组使用比较少，用的多还是slice
k := []int {1,2,3,4,5}  // slice

myMap = make(map[string]string) // map
keyString := "key"; 

myMap[keyString] =  "value"

capital, ok := myMap [ keyString ] /*如果确定是真实的,则存在,否则不存在 */


type H struct {
   first string
   second string
}

h := H{
	first: "1",
	second: "2"
}          // object


var m = func() {
	fmt.Printf("this is function")
}   // function

```

算术操作符，和C语言一样：
```go
z := (5 + 6) * 10
```

## 其次掌握数组和其他集合类的使用，有基础的话可以理解一下泛型，如果理解不了也问题不大，后面可以补；

将string转换为number：
```go
import ("strconv")

intValue, err := strconv.Atoi("12.34")

// 用于把一个字符串解析成浮点数。
floatValue,err := strconv.ParseFloat("123.45",32)
```

math对象需要掌握的方法：
```go

//用于返回数字的整数部分。
floatValue := 12.3
intValue := int(floatValue)  // 12

import (
	"math/rand"
)

x := rand.Intn(100) // 返回 0 ~ 100 之间的随机数

import (
    "math"
)

math.Floor(x)  // 对 x 进行下舍入
```


string需要掌握的方法:
```go
// go 自带 len 方法
txt := "Hello World!"
len := len(txt)

// substring
str := "Hello world!";
fmt.Printf("%s", str[3, 7])

// includes 检测是否包含字符串
import (
    "strings"
)
myString := "apple,banana,orange"
strings.Contains(myString, "banana") // true

// 字符串使用 indexOf() 来定位字符串中某一个指定的字符首次出现的位置：
str := "Hello world, welcome to the universe.";
n := strings.Index(str, "welcome")

// replace将执行一次替换，当第一个 "Microsoft" 被找到，它就被替换为 "Runoob"：
str := "Visit Microsoft! Visit Microsoft!";
n := strings.Replace(str, "Microsoft","Runoob", 1);

// 执行一个全局替换:
str := "Mr Blue has a blue house and a blue car";
n := strings.Replace(str, "blue","red", -1);
```

数组需要掌握的方法:
```go
// go 自带length方法
fruits := []string{"Banana", "Orange", "Apple", "Mango"}
length := len(fruits)

// 数组是否包含指定值，golang没有内置的方法，这个只能自己实现
func contains(s []int, target int) bool {
	for _, v := range s {
		if v == target {
			return true
		}
	}

	return false
}
s := []int{1,2,3}
contains(s, 1) // true

// append
fruits = append(fruits, "Hola")

// 迭代
myStringArray := []string{"Hello","World"}
arrayLength := len(myStringArray)
for i := 0; i < arrayLength; i++ {
		fmt.Printf("%s", myStringArray[i])
    //Do something
}

// for of
colors := []string{'red', 'green', 'blue'}
for _, color := range colors {
		fmt.Printf("%s", color)
}
```

map需要掌握的方法:
```go
// 迭代 

//使用 for of
myMap := make(map[int]string)
myMap[0] = "zero"
myMap[1] = "one"

// 将会显示两个 log。 一个是 "0 = zero" 另一个是 "1 = one"
for key, value := range myMap {
        fmt.Println(key + " = " + value)
}

for key := range myMap {
        fmt.Println(key + " = " + myMap[key])
}

// check whether element is existed in the map or not
capital, ok := myMap [ "key" ] /*如果确定是真实的,则存在,否则不存在 */

```

## 简单字符串处理。所谓简单，就是Regex和Parser以下的内容，什么查找替换，截断去字串之类的。不过这个阶段有一个难点，就是字符编码问题。如果理解不了，可以先跳过，否则的话最好在这时候把这个问题搞定，免留后患；

```go
上面已经写了 string的replace方法
```

## 基本面向对象或者函数式编程的特征，无非是什么继承、多态、Lambda函数之类的，如果有经验的话很快就明白了；

```go
golang 里面并没有面向对象编程，有的只有interface

golang没有class，所以没有继承，但是可以通过interface来实现多态
```

## 异常、错误处理、断言、日志和调试支持，对单元测试的支持。你不一定要用TDD，但是在这个时候应该掌握在这个语言里做TDD的基本技能；

```go
golang 自带了test， 使用 _test.go 文件就能执行单元测试
```

## 程序代码和可执行代码的组织机制，运行时模块加载、符号查找机制，这是初学时的一个难点，因为大部分书都不太注意介绍这个极为重要的内容

```go
// golang 是使用包管理机制, 类似于JAVA

// 在每一个文件的头部都需要加上 package

package golang

// 函数第一个字母是大写的，就等于是自动export，可以被外界使用
func TheFunc() {

}

// struct name 第一个字母是大写的，也是自动export
type TheStruct struct {

}
```

其他go文件就可以通过import命令加载这个模块。
```go
// ES6模块

import (
	"github.com/go/golang"
)

// call other package's function
golang.TheFunc()
```

## 基本输入输出和文件处理，输入输出流类的组织，这通常是比较繁琐的一部分，可以提纲挈领学一下，搞清楚概念，用到的时候查就是了。到这个阶段可以写大部分控制台应用了

golang 命令行输入
```go
// 使用  os.Args
import (
	"os"
)

// 它公开了 argv 属性，该属性是一个包含所有命令行调用参数的数组。
// 第一个参数是 go 命令的完整路径。
// 所有其他的参数从第二个位置开始。
// 比如：go run main.go 1 3 -X ?

for idx, args := range os.Args {
		fmt.Println("参数" + strconv.Itoa(idx) + ":", args)
	}
```

golang 读取文件：
```go
import (
   "io/ioutil"
)

func main() {
   filepath := "D:/gopath/src/golang_development_notes/example/log.txt"
   content ,err :=ioutil.ReadFile(filepath)
   if err !=nil {
      panic(err)
   }
   
   err = ioutil.WriteFile(filePath, newData, os.ModePerm)
   if err != nil {
			return fmt.Errorf("error while writing to file : %v", err)
		}
}
```

## 该语言如何进行callback方法调用，如何支持事件驱动编程模型。在现代编程环境下，这个问题是涉及开发思想的一个核心问题，几乎每种语言在这里都会用足功夫，.NET的delegate，Java的anonymous inner class，Java 7的closure，C++OX的 tr1::function/bind，五花八门。如果能彻底理解这个问题，不但程序就不至于写得太走样，而且对该语言的设计思路也能有比较好的认识；

```go
golang 没有事件驱动编程模型
```

## 如果有必要，可在这时研究regex和XML处理问题，如无必要可跳过；

```go
//regex 已经学习过了
```

## 序列化和反序列化，掌握一下缺省的机制就可以了；

```go
import (
	"encoding/json"
)

// 序列化成为JSON
type Class struct {
    Foo  int  `json:"foo"`
}

myClass := new(Class)
myClass.Foo = 3
    
jsons, err := json.Marshal(myClass)

// 反序列化
var m Class
err := json.Unmarshal(jsons, &m)
```

## 如果必要，可了解一下线程、并发和异步调用机制，主要是为了读懂别人的代码，如果自己要写这类代码，必须专门花时间严肃认真系统地学习，严禁半桶水上阵

```go
//golang 没有线程，只有协程, golang 通过 go 命令执行一个协程
```

## 动态编程，反射和元数据编程，数据和程序之间的相互转化机制，运行时编译和执行的机制，有抱负的开发者在这块可以多下些功夫，能够使你对语言的认识高出一个层面；

```go
//C/C++ 语言没有支持反射功能，只能通过 typeid 提供非常弱化的程序运行时类型信息。Java、C# 等语言都支持完整的反射功能。

// Lua、JavaScript 类动态语言，由于其本身的语法特性就可以让代码在运行期访问程序自身的值和类型信息，因此不需要反射系统。

// Go 程序的反射系统无法获取到一个可执行文件空间中或者是一个包中的所有类型信息，需要配合使用标准库中对应的词法、语法解析器和抽象语法树（AST）对源码进行扫描后获得这些信息。

import (
    "reflect"
)

// Go语言中的反射是由 reflect 包提供支持的，它定义了两个重要的类型 Type 和 Value 任意接口值在反射中都可以理解为由 reflect.Type 和 reflect.Value 两部分组成，并且 reflect 包提供了 reflect.TypeOf 和 reflect.ValueOf 两个函数来获取任意对象的 Value 和 Type。

func main() {
    var a int
    typeOfA := reflect.TypeOf(a)
    fmt.Println(typeOfA.Name(), typeOfA.Kind())
}
```

## 如果有必要，可研究一下该语言对于泛型的支持，不必花太多时间，只要能使用现成的泛型集合和泛型函数就可以了，可在以后闲暇时抽时间系统学习。需要注意的是，泛型技术跟多线程技术一样，用不好就成为万恶之源，必须系统学习，谨慎使用，否则不如不学不用；

```go
golang 目前还不支持泛型编程
```

## 如果还有时间，最好咨询一下有经验的人，看看这个语言较常用的特色features是什么，如果之前没学过，应当补一下。比如Ruby的block interator, Java的dynamic proxy，C# 3的LINQ和extension method。没时间的话，我认为也可以边做边学，没有大问题。

```go
// go语言的feature在于它的interface，和go协程，和channel通信
```

## 有必要的话，在工作的闲暇时间，可以着重考察两个问题，第一，这个语言有哪些惯用法和模式，第二，这个语言的编译/解释执行机制。